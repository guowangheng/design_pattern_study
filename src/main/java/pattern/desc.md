#本模块主要对23种设计模式中比较常见的十五种设计模式做了大致的描述与代码示例。以下是模式与对应包名：

[策略模式](./strategy)
#    策略模式： 将行为特征抽离出来变成接口（抽象策略角色），不同的角色实现该接口（具体策略角色），
#             在环境类中定义接口属性（环境角色），调用接口的方法，通过传入的具体的实现来执行不同的逻辑。
#遵循设计原则：  封装变化的概念；面向接口编程。

[观察者模式](./observer)
#  观察者模式： 观察者即为订阅者， 主题需要实现发布的接口（jdk为Observable类）， 观察者需要实现更新接口
#             Observer接口。观察者调用主题的订阅接口或取消订阅接口来实现（构造方法传入主题对象），
#	 	      主题发生改变后， 会调用setChanged（）方法和notifyObservers（）方法，
#	   	      notifyObservers方法中会调用观察者的Observer中的update方法。
#	 	      jdk提供的是线程安全的。 （气象站案例）

[装饰者模式](./decorator)
#  装饰者模式：  用来加强某个被装饰类的功能， 通过传入基类的实例， 在重写的方法中通过调用实例的方法，
#              来满足原先的功能， 然后在之前或之后加上自己的功能， 来达到增强的目的。
#       缺点：  产生的类比较多。
#遵循设计原则：  对象之间松耦合。

[工厂模式](./factory)
#   工厂模式：  就是将创建对象的工作， 统一交给工厂类集中去做， 消费类只需要传入特点参数获取即可。

[单例模式](./singleton)
#   单例模式：  单例模式主要是控制对象的创建只会执行一次， 单例主要分为饿汉模式和懒汉模式。
#              其中懒汉模式在多线程环境下， 会存在线程安全性问题， 主要有两种方式：
#              双重检查加锁制；静态内部类。

[代理模式](./proxy)
#     代理模式：  代理模式提供了对目标对象另外的访问方式， 通过代理对象访问目标对象， 
#               这样可以在不修改原代码的情况下， 对原有功能实现增强。
#     静态代理：  静态代理装饰者模式在代码上基本无区别， 区别是在思想上， 装饰者是起到增强作用， 
#               但不会阻碍原方法的执行， 而静态代码可能会忽略原方法逻辑执行。
#  JDK动态代理：  JDK动态代理是通过反射机制生成一个实现代理接口的匿名类， 在调用具体方法前调用InvokeHandler来处理
#CGLIB动态代理：  CGLIB动态代理是通过修改对象类的class文件生成子类的方式来处理的。
#静态动态代理区别: 静态代理是在编译时就建立的代理类，动态代理是运行时才会生成代理对象，静态代理代码量更多，
#               动态代理更加解耦合，复用性更强，
#JDK和CGLIB区别： JDK实现需要被代理类存在接口， CGLIB实现需要被代理类没有被final修饰。
#               性能上来说， JDK生成代理对象要更快， 但执行代理方法会慢些， CGLIB生成代理对象会很慢， 
#               但执行方法效率高， 所以如果是单例模式的话， CGLIB会更合适。

[责任链模式](./dutyChain)
#    责任链模式： 为请求创建了一个接收者对象的链，通常每个接收者都包含下一个接收者的引用。
#               处理完后会把相同的请求传给下一个接收者。

[命令模式](./strategy)

[适配器模式](./strategy)

[外观模式](./strategy)

[模板方法模式](./strategy)

[迭代器模式](./strategy)

[组合模式](./strategy)

[状态模式](./strategy)

[复合模式](./strategy)
